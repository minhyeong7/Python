
print("===========re===========")

import re

data ="""
park 800905-1049118
kim  700905-1059119
"""


pat = re.compile("(\d{6})-\d{7}")
print(pat.sub("\g<1>-*******",data))

# (기초) 메타 문자

# . ^ $ * + ? { } [ ] \ | ( )

# -----[]문자 클래스-----
# [abc]  >>> a,b,c 중 정확히 한 개의 문자가 있으면 매치
# "a"   -> 매치
# "before" -> b가 있어서 매치
# "dude"   -> 매치되지 않음

# [a-c] => [abc]
# [0-5] => [012345]
# [A-Z] => 알파벳 대문자
# [a-zA-Z] => 모든 알파벳
# [0-9] => 모든 숫자
# [가~힣] => 모든 한글
# [^0-9] => 숫자가 아닌 모든 문자 (알파벳, 특수문자, 공백 등)
# [^abc] => a,b,c가 아닌 모든 문자
# [^A-Z] => 대문자 알파벳이 아닌 모든 문자

# 자주 사용되는 문자 클래스 []
# \d ==> [0-9] ==> 숫자
# \D ==> [^0-9]  ==> 숫자가 아닌 것
# \s ==> 공백 [ \t\n\r\f\v]
# \S ==> 공백이 아닌것 
# \w ==> 문자+숫자 ==> [a-zA-Z0-9_]
# \W ==> \w의 반대  [^a-zA-Z0-9_]



# ----- .(dot)문자------
# \n을 제외한 모든 문자
# a.b --> ex) a1b a-b a@b 등등 ==> a 모든 문자 b
# a[.]b ==> 'a.b'

# ----- * 문자 ------
# * 바로 앞에 있는 문자 0~ 무한대 반복
# cat*t ==> ct cat caat  caaat


# ------ + 문자 ------
# * 바로 앞에 있는 문자 1~ 무한대 반복
# ca+t ==> ct

# {} 문자 ? 문자 -------
# {m} 바로 앞에 있는 문자 m번 반복
# {m,n} 바로 앞에 있는 문자 m~n회 반복
# {m,} 바로 앞에 있는 문자 m이상 반복
# {, n} 바로 앞에 있는 문자 n 이하 반복

# {0, }  === *
# {1, }  === +

# ca{2}t  ==> caat
# ca{2,5}t  ==> caat caaat caaaat caaaaaat

# ----- ? 문자 -----
# 0 번 혹은 1번 (나오거나 안나오거나)
# {0,1}과 동일
# 
#  ab?c ===> abc ac

# ------ \b ------
# 단어 구분자. 보통 화이트스페이스에 의해 구분.
# \s ==> (화이트스페이스) 공백 [\t\n\r\f\v]

# "cat catalog scatter cat hello"
# \bcat\b  ==> "cat ~~~" "a cat b" "a cat b" "adf cat." "adf cat!"
#  cat  ==> cat cat cat cat
# cat\s ==> bcat이 잡혀서 실패
# \scat\s  ==>  맨앞 cat 안잡혀서 실패



# ------ r" " ------
# raw string(로우 스트링)
# 백슬래시(\) 처리를 더 안전하고 명확하게 하기 위함.
# 이걸 안하면 파이썬이 먼저 해석하고 정규식에 전달
# ==> 원치 않은 결과가 나올수 있다


# 컴파일 옵션
# DOTALL(S) - .(dot)이 줄바꿈 문자를 포함해서 매치
# IGNORECASE(I) - 대소문자 상관없이 매치
# MULTILINE(M) - 여러줄과 매치 가능 ^ $ 관계 깊음


